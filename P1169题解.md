---
title: P1169题解
date: 2023-01-17 20:12:45
tags:
- DP
categories: 题解
url: solution-P1169
excerpt: 悬线法
---
## [ZJOI2007]棋盘制作

### 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公`小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友`小W`决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？

### 输入格式

包含两个整数 $N$ 和 $M$，分别表示矩形纸片的长和宽。接下来的 $N$ 行包含一个 $N\times M$ 的$01$矩阵，表示这张矩形纸片的颜色（$0$ 表示白色，$1$ 表示黑色）。

### 输出格式

包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。

### 样例 #1

#### 样例输入 #1

```in
3 3
1 0 1
0 1 0
1 0 0
```

#### 样例输出 #1

```out
4
6
```

### 提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$

---

## 题解

首先介绍一下一种奇妙的方法——悬线法。

悬线法，主要用来解决最大子矩形问题，由王知昆在 `IOI2003` 国家集训队论文中提出。

所谓“最大子矩形问题”，就是在一个给定的矩形网格中有一些障碍点，要找出网格内部不包含任何障碍点，且边界与坐标轴平行的最大矩形。

所谓悬线，就是对于一类线段，除了两个端点之外，不覆盖任何障碍点，我们称它为有效线段；上端点覆盖了一个障碍点或达到整个矩形上端的有效线段，就是悬线，相当于宽为$0$的矩形。

举个栗子，下面这几条线，都是悬线：

![](https://photo-1314795557.cos.ap-beijing.myqcloud.com/03E40D0B-D038-4f08-AFEB-226768F4ED0B.png)

所谓悬线法，就是先找出每一个点对应的悬线的长度，然后左右移动找到对应的最大宽度。

用一张图来看一下，会发现每一个极大矩形都可以由悬线扩展而来：

![](https://photo-1314795557.cos.ap-beijing.myqcloud.com/v2-59ecef69249834874fb1939e1029604c_r.jpg)

定义几个变量：（天下苦不写变量名久矣）

- `left[i][j]` 表示底部为 $(i,j)$ 的悬线能到达的最左位置。
- `right[i][j]` 表示底部为 $(i,j)$ 的悬线能到达的最右位置。
- `height[i][j]` 表示从 $(i,j)$ 能向上扩展的最大高度。

状态转移方程：
$$
\begin{align}
&\text{height}(i,j)=\text{height}(i-1,j)+1\\
&\text{left}(i,j)=\max(\text{left}(i-1,j),\text{left}(i,j))\\
&\text{right}(i,j)=\min(\text{right}(i-1,j),\text{right}(i,j))
\end{align}
$$
可以在 $O(1)$ 的时间复杂度内完成对每条悬线的操作。

对于这道题来说，以长方形、正方形讨论即可。题目要求 $01$ 交错，所以只需要相邻的点不相等即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=2005;
int gg[maxn][maxn],leftt[maxn][maxn]/*万能头里有left函数*/,rightt[maxn][maxn],height[maxn][maxn],N,M,ans1,ans2;

int main()
{
	cin>>N>>M;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
		{
			cin>>gg[i][j];
			leftt[i][j]=rightt[i][j]=j;//建立悬线
			height[i][j]=1;//初始化，如果上下两个点相同也可以有一条长度为1的悬线
		}
	for(int i=1;i<=N;i++)
		for(int j=2;j<=M;j++)//注意从2开始
			if(gg[i][j]!=gg[i][j-1])
				leftt[i][j]=leftt[i][j-1];//预处理左边界
	for(int i=1;i<=N;i++)
		for(int j=M-1;j>0;j--)//注意从M-1开始
			if(gg[i][j]!=gg[i][j+1])
				rightt[i][j]=rightt[i][j+1];//预处理右边界，注意要从终边开始减
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
		{
			if(i>1&&gg[i][j]!=gg[i-1][j])
			{
				leftt[i][j]=max(leftt[i][j],leftt[i-1][j]);
				rightt[i][j]=min(rightt[i][j],rightt[i-1][j]);
				height[i][j]=height[i-1][j]+1;
			}
			int a=rightt[i][j]-leftt[i][j]+1/*横向长度*/,b=min(a,height[i][j]);
			ans1=max(ans1,b*b);ans2=max(ans2,a*height[i][j]);
		}
	cout<<ans1<<endl<<ans2;
	return 0;
}
```

