---
title: P5626题解
date: 2023-02-06 19:13:43
tags: 排序
categories: 题解
url: solution-P5626
excerpt: 很遗憾，您上传的题解 P5626题解 未能通过审核。原因是 审核管理员：_RSY_，对审核结果有疑问可以私信；应当补充重要结论的证明与对解法进一步的说明。
---

# 数码排序

## 题目背景

小L从虚拟世界里出来啦！

---

**加强版[链接](https://www.luogu.org/problem/P5634)**

## 题目描述

逃出来的同时，也有一部分数码逃了出来，吵着闹着让小L帮他们排序

虚拟世界的数码都是不可见的

小L目前只会选择排序，插入排序，冒泡排序，归并排序

所以小L想问他在最坏情况下最少需要几次比较，才能使序列有序

-------

[排序的模板代码](https://www.luogu.org/paste/fdtepscp)

## 输入格式

输入仅有一行，给定一个正整数 $n$，表示序列的长度

## 输出格式

输出最小的比较次数

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
5
```

## 样例 #2

### 样例输入 #2

```
5
```

### 样例输出 #2

```
8
```

## 提示

- **样例$1$解释**

长度为$4$的序列归并调用，分成$2$组，一组$2$个元素。$2$个元素分别比较一次， 合并时最坏比较$3$次，所以是$3+1+1=5$。

- **数据范围**

对于$10\%$的数据，$n \leq 1000$

对于$30\%$的数据，$n \leq 1000000$

对于$100\%$的数据，$n \leq 10^{16}$

**数据保证随机**

---

# 题解

首先，关于选择哪种排序方式，显然是归并排序最快。

给不熟悉归并排序的同学一张图解释一下。

![](https://photo-1314795557.cos.ap-beijing.myqcloud.com/66a98e503c434e7eb816711181454bcd.gif)

然后我们就可以愉快地打表找规律啦！

| $n$  | $f(n)$ |
| :--: | :----: |
| $1$  |  $0$   |
| $2$  |  $1$   |
| $3$  |  $3$   |
| $4$  |  $5$   |
| $5$  |  $8$   |
| $6$  |  $11$  |
| $7$  |  $14$  |
| $8$  |  $17$  |
| $9$  |  $21$  |
| $10$ |  $25$  |

这样一列出来之后，规律就很显而易见了：

- 当 $n$ 是奇数时，$f(n)=f(\dfrac{n}{2})+f(\dfrac{n}{2}+1)+n-1$

- 当 $n$ 是偶数时，$f(n)=2\times f(\dfrac{n}{2})+n-1$

有了这样的规律之后，代码实现就非常简单了！

温馨提示：

- 不开 `long long` 见祖宗哟！
- 注意开始的特判

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,m,gg=1,ans,x=1;
signed main()
{
    int n;cin>>n;
	if(n==1) puts("0"),exit(0);
	a=n-1;
	while(a) m++,a/=2;
	for(int i=1;i<=m;i++) gg*=2;
	for(int i=1;i<=m;i++)
		ans+=(i*x),x*=2;
	ans-=((gg-n)*m);
    cout<<ans;
	return 0;
}
```

