---
title: P1443题解
date: 2022-11-29 15:23:30
categories: 题解
tags:
- BFS
url: solution-P1443
---

# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 样例 #1

### 样例输入 #1

```in
3 3 1 1
```

### 样例输出 #1

```out
0    3    2    
3    -1   1    
2    1    4
```

## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

---

# 题解

广度优先搜索，会优先考虑每种状态和初始状态的距离，形象点说，与初始状态越接近的情况就会越先考虑。再具体一点，每个时刻（阶段）要做的事情就是从上个时刻（阶段）每个状态扩展出新的状态。

广度优先搜索使用队列实现：先将初始状态加入到空的队列中，然后每次取出队首，找出队首所能转移到的状态，再将其压入队列。如此反复，直到队列为空。这样就能保证一个状态在被访问的时候一定是采用的最短路径。

就本题而言，先建立一个结构体数组用于存储扩展的结点。先让起点入队，然后在队列取状态逐个扩展。

代码：

```cpp
#include<bits/stdc++.h>  
using namespace std;  

struct coord
{
    int x,y;
};

queue<coord> q;

int ans[305][305];
int walk[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};


int main()  
{  
    int m,n,sx,sy;
    memset(ans,-1,sizeof(ans));
    cin>>n>>m>>sx>>sy;
    coord tmp={sx,sy};
    q.push(tmp);
    ans[sx][sy]=0;
    while(!q.empty())
    {
        coord u=q.front();
        int ux=u.x,uy=u.y;
        q.pop();//出队
        for(int k=0;k<8;k++)
        {
            int x=ux+walk[k][0],y=uy+walk[k][1];
            int d=ans[ux][uy];
            if(x<1||x>n||y<1||y>m||ans[x][y]!=-1)
            {
                continue;
            }
            ans[x][y]=d+1;
            coord tmp={x,y};
            q.push(tmp);//入队
        }
    }

    for(int i=1;i<=n;i++,puts(" "))
        for(int j=1;j<=m;j++)
            printf("%-5d",ans[i][j]);

    return 0;  
}  
```