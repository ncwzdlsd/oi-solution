---
title: P4799题解
date: 2023-02-10 18:50:31
tags:
- 折半搜索
categories: 题解
url: solution-P4799
excerpt: 被迫营业
---

# [CEOI2015 Day2] 世界冰球锦标赛

## 题目描述

**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day2 T1「[Ice Hockey World Championship](https://ceoi2015.fi.muni.cz/day2/eng/day2task1-eng.pdf)」**

> 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

## 输入格式

第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。  

第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。

## 输出格式

输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。

## 样例 #1

### 样例输入 #1

```in
5 1000
100 1500 500 500 1000
```

### 样例输出 #1

```out
8
```

## 提示

#### 样例解释
八种方案分别是：

 - 一场都不看，溜了溜了  
 - 价格 $100$ 的比赛  
 - 第一场价格 $500$ 的比赛  
 - 第二场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第一场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第二场价格 $500$ 的比赛  
 - 两场价格 $500$ 的比赛  
 - 价格 $1000$ 的比赛

有十组数据，每通过一组数据你可以获得 $10$ 分。各组数据的数据范围如下表所示：

| 数据组号 | $1-2$  |   $3-4$   | $5-7$  |  $8-10$   |
| -------- | :----: | :-------: | :----: | :-------: |
| $N \leq$ |  $10$  |   $20$    |  $40$  |   $40$    |
| $M \leq$ | $10^6$ | $10^{18}$ | $10^6$ | $10^{18}$ |

---

# 题解

前置芝士：折半搜索（meet in the middle），一种很玄学的搜索方法。

这道题属于\*谷上比较水的折半搜索了。~~佩服自己找水题的能力~~

从看到这道题的题干到数据范围，出题人仿佛处处都写着：“我是折半搜索，快来切了我”，但是蒟蒻之前一直没有做过折半搜索的题，又因为 Kazdale 让蒟蒻找一道折半搜索的题，于是只能被迫营业了。

首先考虑正常的搜索，一路走到黑时间复杂度是 $O(2^{40})$，一定炸！

所以考虑折半搜索，从两边对着搜，具体就是搜索 $1\sim\dfrac{n}{2}$、$\dfrac{n}{2}+1\sim n$ 两个区间内的最优解。这样优化之后，时间复杂度就变为 $O(2^{\frac{n}{2}+1})$。~~这不爽死了嘛~~

第一遍搜索前半部分时，我们的限制是不超过 $M$。可以记录此时对于一个合法方案，它的消耗钱数 `sum` 是多少。

到了第二遍搜索后半部分时，需要知道的是，我们可以统计的方案是前后加一起小于 $M$ 的方案。于是乎我们先对第一次得到的方案进行 `sort`，枚举选后一半的所有情况，如果和前一半合并之后总钱数仍小于 $M$，可以把这些可能全部累计到 `ans` 中。由于前一半的方案已经被我们排成有序的了，所以我们可以用 `upper_bound` 函数快速查找出可以统计的情况。

具体代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

// 对于此题的两次 DFS 来说，要统计 1 个 sum（当前消耗钱数）和 pos（已经搜到哪里了）

const int maxn=1<<25;//左移 25 位相当于 2 的 25 次方
int q1[maxn],q2[maxn],co[45],ans,N,M,cnt1,cnt2,mid;

void dfs1(int sum,int pos)
{
    if(sum>M) return;
    if(pos>mid) {q1[++cnt1]=sum;return;}
    dfs1(sum+co[pos],pos+1);
    dfs1(sum,pos+1);//考虑不选当前位，继续向下搜
}

void dfs2(int sum,int pos)
{
    if(sum>M) return;
    if(pos>N) {q2[++cnt2]=sum;return;}
    dfs2(sum+co[pos],pos+1);
    dfs2(sum,pos+1);
}

signed main()
{
    cin>>N>>M;
    mid=(N+1)/2;
    for(int i=1;i<=N;i++) cin>>co[i];
    dfs1(0,1);
    sort(q1+1,q1+cnt1+1);
    dfs2(0,mid+1);
    for(int i=1;i<=cnt2;i++)
    	ans+=upper_bound(q1+1,q1+cnt1+1,M-q2[i])-q1-1;
    // cout<<cnt<<endl;
    // cout<<N/2<<endl;
    cout<<ans;
    return 0;
}
```

注意：不开 `long long` 见祖宗，实测 $20$ 分/kk/kk
