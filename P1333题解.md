---
title: P1333题解
date: 2023-01-19 09:13:04
tags:
- 图论
- 欧拉回路
- STL
- 并查集
categories: 题解
url: solution-P1333
---

# 瑞瑞的木棍

## 题目描述

瑞瑞有一堆的玩具木棍，每根木棍的两端分别被染上了某种颜色，现在他突然有了一个想法，想要把这些木棍连在一起拼成一条线，并且使得木棍与木棍相接触的两端颜色都是相同的，给出每根木棍两端的颜色，请问是否存在满足要求的排列方式。

例如，如果只有 $2$ 根木棍，第一根两端的颜色分别为 red, blue，第二根两端的颜色分别为 red, yellow，那么 blue---red | red----yellow 便是一种满足要求的排列方式。

## 输入格式

输入有若干行，每行包括两个单词，表示一根木棍两端的颜色，单词由小写字母组成，且单词长度不会超过 $10$ 个字母，最多有 $250000$ 根木棍。

## 输出格式

如果木棒能够按要求排列，输出 `Possible`，否则输出 `Impossible`

## 样例 #1

### 样例输入 #1

```in
blue red
red violet
cyan blue
blue magenta
magenta cyan
```

### 样例输出 #1

```out
Possible
```

---

# 题解

一眼就看出是欧拉路了诶。

首先打出一套并查集的合并、查找板子😁

对于点的编号，我们可以采用 STL 中的 `unordered_map` 实现，但是据说这玩意儿很慢，我也不知道捏。

于是乎，这道题就转化为一道欧拉路的问题。注意，这里是欧拉路径而不是欧拉回路。

还有一点需要注意，应该判断一下图是否是连通图，如果有 $N$ 个点，合并了 $M$ 次，当且仅当 $M=N-1$ 时图是连通图。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int du[500005],fa[500005],n;
char s[15];

int find(int x)
{
	if(x!=fa[x]) fa[x]=find(fa[x]);
	return fa[x];
}

bool unionn(int x,int y)//判断能否合并
{
	int xx=find(x),yy=find(y);
	if(xx==yy) return false;//相同不能合并
	fa[xx]=yy;return true;//合并
}

unordered_map<string,int> m;
//map默认按key从小到大排序，这里无需这种操作
int getid(const char *s)
{
	if(m[s]) return m[s];
	return m[s]=++n;
}

bool check()
{
	int cnt=0,xx,yy;
	for(int i=1;i<=50005;i++) fa[i]=i;
	while(~scanf("%s",s))
	{
		xx=getid(s);
		scanf("%s",s);yy=getid(s);
		if(unionn(xx,yy)) ++cnt;//记录合并次数
		++du[xx],++du[yy];
	}
	if(cnt<n-1) return false;
	cnt=0;//改为记录度数为奇数的点的个数
	for(int i=1;i<=n;i++) if((du[i]&1)&&++cnt>2) return false;
	return true;
}

int main()
{
	puts(check()?"Possible":"Impossible");
	return 0;
}
```
