---
title: P2921题解
date: 2023-01-20 08:27:41
tags:
- DFS
categories: 题解
url: solution-P2921
excerpt: 朴素而不失高级的DFS
---

# [USACO08DEC]Trick or Treat on the Farm G

## 题面翻译

#### 题目描述

每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在$N$($1\leq N\leq100,000$)个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。

由于牛棚不太大，FJ通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ在第i号隔间上张贴了一个“下一个隔间” $\text{Next}_i$($1\leq \text{Next}_i\leq N$)，告诉奶牛要去的下一个隔间；这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。

FJ命令奶牛i应该从i号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。

在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。

#### 输入格式

第 $1$ 行一个整数 $n$。

第 $2$ 行到 $n+1$ 行 每行包含一个整数 $\text{Next}_i$。

#### 输出格式

$n$ 行，第 $i$ 行包含一个整数，表示第 $i$ 只奶牛要前往的隔间数。

#### 样例解释

有 $4$ 个隔间。

隔间 $1$ 要求牛到隔间 $1$；

隔间 $2$ 要求牛到隔间 $3$；

隔间 $3$ 要求牛到隔间 $2$；

隔间 $4$ 要求牛到隔间 $3$。

牛 $1$，从 $1$ 号隔间出发，总共访问 $1$ 个隔间；

牛 $2$，从 $2$ 号隔间出发，然后到 $3$ 号隔间，然后到 $2$ 号隔间，终止，总共访问 $2$ 个隔间；

牛 $3$，从 $3$ 号隔间出发，然后到 $2$ 号隔间，然后到 $3$ 号隔间，终止，总共访问 $2$ 个隔间；

牛 $4$，从 $4$ 号隔间出发，然后到 $3$ 号隔间，然后到 $2$ 号隔间，然后到3号隔间，终止，总共访问 $3$ 个隔间。

翻译提供者：吃葡萄吐糖

## 题目描述

Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the $N$ ($1\leq N\leq100,000$) stalls conveniently numbered $1\cdots N$.

Because the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow.  To implement this scheme for traveling back and forth through the barn, FJ has posted a 'next stall number' $\text{Next}_i$ ($1\leq \text{Next}_i\leq N$) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy.

FJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited.

Calculate the number of unique stalls each cow visits before being forced to stop her candy collection.

POINTS: $100$

## 输入格式

\* Line $1$: A single integer: $N$

\* Lines $2\cdots N+1$: Line $i+1$ contains a single integer: $\text{Next}_i$

## 输出格式

\* Lines $1\cdots N$: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall  she has previously visited.

## 样例 #1

### 样例输入 #1

```in
4 
1 
3 
2 
3
```

### 样例输出 #1

```out
1 
2 
2 
3
```

## 提示

Four stalls.

\* Stall $1$ directs the cow back to stall $1$.

\* Stall $2$ directs the cow to stall $3$

\* Stall $3$ directs the cow to stall $2$

\* Stall $4$ directs the cow to stall $3$


Cow $1$:  Start at $1$, next is $1$.  Total stalls visited: $1$.

Cow $2$:  Start at $2$, next is $3$, next is $2$. Total stalls visited: $2$. Cow $3$:  Start at $3$, next is $2$, next is $3$.  Total stalls visited: $2$. Cow $4$:  Start at $4$, next is $3$, next is $2$, next is $3$. Total stalls visited: $3$.

---

# 题解

~~好烦啊为什么他们写题目都不用 $\LaTeX$ 啊~~

这道题看上去其实没有什么特别的思路，~~于是乎我们打开题解，~~发现其实这道题可以看成一个有向图，每个点的出度为 $1$。不知道为什么有大佬说要用 Tarjan，所以我选择朴素做法。

每只奶牛的终止条件是到达自己已经访问过的点，换言之，就是该奶牛的路线构成了一个环。并且，每一个房间通往的房间都是固定且唯一的，所以说只要进入的这个房间在环上，这个房间之后会获得的糖果数已经固定了。

于是乎我们开一个数组 `s` 记录当前位置的糖果数量，用 `vis` 数组记录房间的访问情况。对于一个已经访问过得房间，我们只需要用在这个房间的糖果数量减去上一次来这个房间的糖果数量，就可以得到当前房间所在环上的糖果数量，我们用`h`数组记录。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e5+5;
int nxt[maxn],h[maxn],s[maxn],flag,n;
bool vis[maxn];

int dfs(int now,int nowc)//起始位置 当前糖果数
{
	if(h[now]) return nowc-1+h[now];//当前房间的糖果不能重复累加，要-1
	if(vis[now]==1)
	{
		h[now]=nowc-s[now];flag=now;
		return nowc-1;
	}
	vis[now]=1;s[now]=nowc;
	int ans=dfs(nxt[now],nowc+1);//当前位置符合，继续向下一个位置DFS
	if(flag)
	{
		if(now==flag) flag=0;
		else h[now]=h[flag];
	}
	else h[now]=h[nxt[now]]+1;
	vis[now]=false;
	return ans;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>nxt[i];
	for(int i=1;i<=n;i++) cout<<dfs(i,1)<<endl;
	return 0;
}
```



