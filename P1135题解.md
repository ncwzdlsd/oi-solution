---
title: P1135题解
url: solution-P1135
categories: 题解
tags:
- BFS
date: 2022-11-29 17:34:49
---

# 奇怪的电梯

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？

## 输入格式

共二行。  

第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。

第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。

## 输出格式

一行，即最少按键次数，若无法到达，则输出 `-1`。

## 样例 #1

### 样例输入 #1

```in
5 1 5
3 3 1 2 5
```

### 样例输出 #1

```out
3
```

## 提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

---

# 题解

从起点开始，往上或者往下扩展，可以到达“按$1$次按钮的地方”。这些“按$1$次按钮的地方”再分别往上或往下扩展（前提是在大厦范围内，且没有访问过），就可以到达“按$2$次按钮的地方”。

使用广度优先搜索。

代码如下：

```cpp
#include<bits/stdc++.h>  
using namespace std;  

struct node
{
    int floor,d;
    //d是按钮次数
};

queue<node> q;

int n,a,b;
int k[1005],vis[1005];

int main()  
{  
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)
    {
        cin>>k[i];
    }

    q.push(node{a,0});
    vis[a]=1;
    node now;

    while(!q.empty())
    {
        now=q.front();
        q.pop();//出队
        if(now.floor==b)
        {
            break;
        }
        for(int sign=-1;sign<=1;sign+=2)
        {
            int dist=now.floor+k[now.floor]*sign;
            if(dist>=1&&dist<=n&&vis[dist]==0)
            {
                q.push((node){dist,now.d+1});
                vis[dist]=1;
            }
        }
    }

    if(now.floor==b)
    {
        cout<<now.d<<endl;
    }
    else
    {
        cout<<-1<<endl;
    }

    return 0;  
}  
```