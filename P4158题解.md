---
title: P4158题解
date: 2023-01-18 14:18:19
tags:
- DP
categories: 题解
url: solution-P4158
excerpt: 朴素DP，却是紫题
---

# [SCOI2009]粉刷匠

## 题目描述

windy 有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。

windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。

如果 windy 只能粉刷 $T$ 次，他最多能正确粉刷多少格子？

一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。

## 输入格式

第一行包含三个整数，$N,M,T$。

接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，'0'表示红色，'1'表示蓝色。

## 输出格式

包含一个整数，最多能正确粉刷的格子数。

## 样例 #1

### 样例输入 #1

```in
3 6 3
111111
000000
001100
```

### 样例输出 #1

```out
16
```

## 提示

30%的数据，满足 1 <= N,M <= 10 ； 0 <= T <= 100 。

100%的数据，满足 1 <= N,M <= 50 ； 0 <= T <= 2500 。

---

# 题解

显然，这是一道DP题。~~（差点没看出来）~~

设$f(i,j)$表示前$i$条木板粉刷$j$次能正确粉刷的最大格子数，$g(i,j,k)$表示第$i$条木板上粉刷$j$次涂了前$k$个格子能正确粉刷的最大格子数，用前缀和数组`sum`记录蓝色格子数（`sum[i][j]`表示第$i$条木板到位置$j$有几个蓝格子），某个区间的格子数减蓝色格子数就是红色格子数。

求能正确粉刷的最大格子数，状态转移方程为：$f(i,j)=\max(f(i,j),f(i-1)(j-k)+g(i,k,M))$。

求$g(i,j,k)$的状态转移方程，要考虑前$r$个格子正确粉刷的最大格子数加上下一步正确粉刷的格子数（这里要比较一下是正确粉刷的蓝格子多还是红格子多）。
$$
g(i,j,k)=\max(g(i,j,k),g(i,j-1,r)+\max(sum(i,k)-sum(i,r),k-r-sum(i,k)+sum(i,r))
$$
代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int f[55][2505],sum[55][2505],g[55][2505][55];
char s[105];

int main()
{
	int N,M,T,ans=0;cin>>N>>M>>T;
	for(int i=1;i<=N;i++) 
	{
		cin>>s;
		sum[i][0]=0;//前缀和初始化
		for(int j=1;j<=M;j++)
		{
			if(s[j-1]=='1') sum[i][j]=sum[i][j-1]+1;//记录当前条的蓝色格子数
			else sum[i][j]=sum[i][j-1];		
		}
	}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=T;j++)
			for(int k=1;k<=T;k++)
				for(int r=j-1;r<k;r++)//因为s数组是从下标为0开始的
					g[i][j][k]=max(g[i][j][k],g[i][j-1][r]+max(sum[i][k]-sum[i][r],k-r-sum[i][k]+sum[i][r]));
	for(int i=1;i<=N;i++)
		for(int j=1;j<=T;j++)
			for(int k=1;k<=min(j,M);k++)
				f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][k][M]);
	for(int i=1;i<=T;i++) ans=max(ans,f[N][i]);
	cout<<ans;
	return 0;
}
```

发现DP题的代码往往很短但是思维含量极高QAQ
